package com.stee.spfcore.service.course.impl;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.stee.spfcore.dao.BlacklistDAO;
import com.stee.spfcore.dao.CalendarDAO;
import com.stee.spfcore.dao.CourseDAO;
import com.stee.spfcore.dao.MarketingDAO;
import com.stee.spfcore.dao.SessionFactoryUtil;
import com.stee.spfcore.model.blacklist.BlacklistModuleNameConstants;
import com.stee.spfcore.model.course.Course;
import com.stee.spfcore.model.course.CourseParticipant;
import com.stee.spfcore.model.course.CourseStatus;
import com.stee.spfcore.model.course.ParticipantStatus;
import com.stee.spfcore.model.course.Slot;
import com.stee.spfcore.model.course.internal.ApplicantSelectionTaskStatus;
import com.stee.spfcore.model.course.internal.OutcomeBroadcastTaskStatus;
import com.stee.spfcore.model.course.internal.WaitListTask;
import com.stee.spfcore.model.personnel.PersonalDetail;
import com.stee.spfcore.service.configuration.IWelfareCourseConfig;
import com.stee.spfcore.service.configuration.ServiceConfig;
import com.stee.spfcore.service.course.CourseServiceException;
import com.stee.spfcore.utils.DateUtils;
import com.stee.spfcore.utils.Util;

public class VacancyAllocationHandler {

	private static final String INTRANET = "INTRANET";
	
	private static Logger logger = Logger.getLogger(VacancyAllocationHandler.class.getName());
	
	private CourseDAO dao;
	private BlacklistDAO blacklistDAO;
	private EmailSmsHelper emailSmsHelper;
	private CalendarDAO calendarDAO;
	
	public VacancyAllocationHandler () {
		dao = new CourseDAO();
		blacklistDAO = new BlacklistDAO();
		emailSmsHelper = new EmailSmsHelper();
		calendarDAO = new CalendarDAO();
	}
	
	public void vacancyAllocation() throws CourseServiceException {
		
		List<Course> courses = null;
		
		try {
			SessionFactoryUtil.beginTransaction();
			
			courses = dao.getCoursesPendingAllocation ();
			SessionFactoryUtil.commitTransaction();
		}
		catch (Exception e) {
			logger.log(Level.SEVERE, "Fail to retrieve courses pending reminder", e);
			SessionFactoryUtil.rollbackTransaction();
		}
		
		// Handle each course in separate transaction. 
		// Fail in allocating one course should not stop others.
		for (Course course : courses) {
			vacancyAllocation (course);
		}
	}
	
	public void vacancyAllocation (Course course) throws CourseServiceException {
		logger.info("Vacancy allocation for course:" + Util.replaceNewLine( course.getId() ) );
		
		try {
			SessionFactoryUtil.beginTransaction();
			
			for (Slot slot : course.getSlots()) {
				vacancyAllocation (course, slot);
			}
			
			if (course.getRegistrationConfig().isAutoOutcomeBroadcast()) {
				emailSmsHelper.informAllocationStatus (course);		
				course.getRegistrationConfig().setOutcomeBroadcasted(true);
				dao.updateCourse(course, INTRANET);
			}
			else {
				Date cutoffDate = computeCutoffDate(course.getRegistrationConfig().getCloseDate(), course.getTakeoverDays());
				// Inform course administrator to confirm the registration outcome generated by the System
				emailSmsHelper.informConfirmRegistrationOutcome(course, cutoffDate);
			}
			
			ApplicantSelectionTaskStatus taskStatus = new ApplicantSelectionTaskStatus(course.getId(), new Date ());
			dao.saveApplicantSelectionTaskStatus(taskStatus);
			
			SessionFactoryUtil.commitTransaction();
		}
		catch (Exception e) {
			logger.log(Level.SEVERE, "Fail to retrieve courses pending reminder", e);
			SessionFactoryUtil.rollbackTransaction();
		}
	}
	
	
	private void vacancyAllocation (Course course, Slot slot) {
		
		logger.info("Vacancy allocation for slot:" + Util.replaceNewLine( slot.getId() ));
		
		int availableSeat = slot.getMaxClassSize();
		if ( logger.isLoggable( Level.INFO ) ) {
			logger.info(String.format("Available seat: %s", availableSeat));
		}
		List<CourseParticipant> participants = dao.getCourseParticipants(course.getId(), slot.getId(), ParticipantStatus.REGISTERED);
		logger.info("Total registered participant:" + participants.size());
		
		// Demand is less than supply. All will be successful
		if (participants.size() <= availableSeat) {
			logger.info("Demand is less than supply");
			
			for (CourseParticipant participant : participants) {
				participant.setStatus(ParticipantStatus.SUCCESSFUL);
				participant.setUpdatedBy("BPM");
				dao.updateCourseParticipant(participant, INTRANET);
			}
		}
		else {
			// Demand is more than supply
			logger.info("Demand is more than supply");
			
			// Get blacklist nric
			List<String> blacklistNrics = blacklistDAO.getBlacklistNrics (BlacklistModuleNameConstants.WELFARE_COURSES);
					
			// Get id of courses with same title id as this course.
			List<String> similarCourseId = dao.getCourseIds (course.getTitleId(), CourseStatus.ACTIVATED);
			similarCourseId.remove(course.getId());
					
			// Step 1: allocate by unit first.
			availableSeat = availableSeat - allocateByUnit (course, slot, blacklistNrics, similarCourseId);
			
			// Step 2: if still have available seats, allocate to uniform, and 
			// civilian, and psnf applicants who has not been allocated a seat in step 1, have not attended before, and not blacklisted
			if (availableSeat > 0) {
				availableSeat = availableSeat - allocateNotAttendedBeforeNotBlacklisted (course, slot, availableSeat, blacklistNrics, similarCourseId);
			}
			
			// Step 3: Any unallocated seats after step 2 will be allocated to those that have attended before but not blacklisted 
			if (availableSeat > 0) {
				availableSeat = availableSeat - allocateAttendedBeforeNotBlacklisted (course, slot, availableSeat, blacklistNrics, similarCourseId);
			}
			
			// Step 4: Any unallocated seats after step 4 will be allocated to those that have been blacklisted
			if (availableSeat > 0) {
				allocateBlacklisted (course, slot, availableSeat);
			}
		}
		
		// Update those that yet to be allocated to UNSUCCESS or WAITLIST
		participants = dao.getCourseParticipants(course.getId(), slot.getId(), ParticipantStatus.REGISTERED);
		for (CourseParticipant participant : participants) {
			if (participant.isAcceptWaitlist()) {
				participant.setStatus(ParticipantStatus.WAIT_LIST);
				participant.setUpdatedBy("BPM");
				dao.updateCourseParticipant(participant, INTRANET);
			}
			else {
				participant.setStatus(ParticipantStatus.UNSUCCESSFUL);
				participant.setUpdatedBy("BPM");
				dao.updateCourseParticipant(participant, INTRANET);
			}
		}
	}
	
	/**
	 * Allocate by unit first. Return number of seat allocated. 
	 */
	private int allocateByUnit (Course course, Slot slot, List<String> blacklistNrics,
								List<String> similarCourseId) {
		
		Map<String, Integer> unitAssignment = computeSeatPerUnit (course, slot);
		
		int allocatedCount = 0;

		for (Map.Entry<String, Integer> entry : unitAssignment.entrySet()) {
			String unitCodeId = entry.getKey();
			int assignedSeat = entry.getValue();

			// If assigned seat is 0, go to next unit
			if (assignedSeat == 0) {
				continue;
			}

			allocatedCount += allocateToUnit(course, slot, assignedSeat, unitCodeId, blacklistNrics, similarCourseId);
		}


		return allocatedCount;
	}
	
	
	private Map<String, Integer> computeSeatPerUnit (Course course, Slot slot) {
		
		logger.info("computeSeatPerUnit for course " + course.getId());
		
		Set<PersonalDetail> personalDetails = getMemberInGroups (course.getMemberGroupIds());
		
		int totalOfficer = personalDetails.size();

		if ( logger.isLoggable( Level.INFO ) ) {
			logger.info(String.format("Targeted personnel: %s", totalOfficer));
		}
		// The list is sorted by the targeted staff in descending order
		List<UnitTargetedStaffInfo> unitTargetedCount = splitByUnit (personalDetails);
		
		int totalAllocatedSeat = 0;
		int classSize = slot.getMaxClassSize();
		
		Map<String, Integer> result = new HashMap<>();
		
		// Assign 1 seat to each unit starting with targeted unit with 
		// the most targeted staffs and work downward
		for (UnitTargetedStaffInfo info : unitTargetedCount) {
			if (totalAllocatedSeat == classSize) {
				break;
			}
			
			result.put(info.getUnitCodeId(), 1);
			totalAllocatedSeat++;
		}
		
		// Still have reminding after assign 1 to each unit
		// allocate using the following formula:
		// (Total staffs in the Unit from the target group / Total staffs in target group) * reminding seats
		if (totalAllocatedSeat < classSize) {
			int availableSeat = classSize - totalAllocatedSeat;
			
			for (UnitTargetedStaffInfo info : unitTargetedCount) {
				int seat = (int) ((info.getTargetedCount() * availableSeat) / totalOfficer);
				int value = result.get(info.getUnitCodeId());
				result.put(info.getUnitCodeId(), (value + seat));
				totalAllocatedSeat += seat;
			}
		}
		
		// If still have reminding seats, allocate 1 seat to each unit starting with 
		// targeted unit with the most targeted staffs and work downward
		for (UnitTargetedStaffInfo info : unitTargetedCount) {
			if (totalAllocatedSeat == classSize) {
				break;
			}
			
			int value = result.get(info.getUnitCodeId());
			result.put(info.getUnitCodeId(), value + 1);
			totalAllocatedSeat++;
		}
		
		return result;
	}


	private List<UnitTargetedStaffInfo> splitByUnit (Set<PersonalDetail> personalDetails) {
		
		List<UnitTargetedStaffInfo> result = new ArrayList<>();
		Map<String, UnitTargetedStaffInfo> unitMap = new HashMap<>();
		
		for (PersonalDetail personalDetail : personalDetails) {
			String unitCodeId = personalDetail.getEmployment().getOrganisationOrDepartment();
			
			UnitTargetedStaffInfo info = unitMap.get(unitCodeId);
			if (info == null) {
				info = new UnitTargetedStaffInfo(unitCodeId, 1);
				result.add(info);
				unitMap.put(unitCodeId, info);
			}
			else {
				int count = info.getTargetedCount() + 1;
				info.setTargetedCount(count);
			}
		}
		
		// Sort the list in descending order using the targeted staff count
		Collections.sort(result);
		
		return result;
	}

	private Set<PersonalDetail> getMemberInGroups (List<String> memberGroups) {
		
		Set<PersonalDetail> set = new HashSet<>();
		MarketingDAO marketingdao = new MarketingDAO();
		
		for (String groupId : memberGroups) {
			List<PersonalDetail> list = marketingdao.getPersonnelInGroup(groupId);
			set.addAll(list);
		}
		
		return set;
	}

	private int allocateToUnit (Course course, Slot slot, int startNum, String unitCodeId, List<String> blacklistNrics, List<String> similarCourseId) {
		
		int availableSeat = startNum;
		
		IWelfareCourseConfig config = ServiceConfig.getInstance().getWelfareCourseConfig();
		
		// Start with Uniformed and Civilian Officers first
		
		List<CourseParticipant> uniformedParticipants = dao.getRegisteredCourseParticipants(course.getId(), slot.getId(), unitCodeId, similarCourseId,
				config.uniformedOfficerServiceTypeCodes(), blacklistNrics);
		
		List<CourseParticipant> civilianParticipants = dao.getRegisteredCourseParticipants(course.getId(), slot.getId(), unitCodeId, similarCourseId,
				config.civilianOfficerServiceTypeCodes(), blacklistNrics);
		
		if (uniformedParticipants.isEmpty()) {
			availableSeat = availableSeat - allocate(civilianParticipants, availableSeat);
		}
		else if (civilianParticipants.isEmpty()) {
			availableSeat = availableSeat - allocate(uniformedParticipants, availableSeat);
		}
		else {
			availableSeat = availableSeat - allocate(uniformedParticipants, civilianParticipants, availableSeat);
		}
		
		// Still have available seat, give to PNSF
		if (availableSeat > 0) {
			List<CourseParticipant> pnsfParticipants = dao.getRegisteredCourseParticipants(course.getId(), slot.getId(), unitCodeId, similarCourseId, 
					config.pnsfOfficerServiceTypeCode(), blacklistNrics);
			availableSeat = availableSeat - allocate(pnsfParticipants, availableSeat);
		}
		
		return startNum - availableSeat;
	}
	
	
	private int allocate (List<CourseParticipant> list1, List<CourseParticipant> list2, int startNum) {
		
		if (startNum == 0) {
			return 0;
		}
		
		int availableSeat = startNum;
		
		List<CourseParticipant> firstList = list1;
		List<CourseParticipant> nextList = list2;
		
		while (availableSeat > 0) {
			if (!firstList.isEmpty()) {
				CourseParticipant participant = firstList.remove(0);
				participant.setStatus(ParticipantStatus.SUCCESSFUL);
				participant.setUpdatedBy("BPM");
				dao.updateCourseParticipant(participant, INTRANET);
				
				availableSeat--;
				
				if (!nextList.isEmpty()) {
					List<CourseParticipant> tempList = firstList;
					firstList = nextList;
					nextList = tempList;
				}
			}
			else if (!nextList.isEmpty()) {
				List<CourseParticipant> tempList = firstList;
				firstList = nextList;
				nextList = tempList;
			}
			else {
				// Both list empty
				break;
			}
		}
		
		return startNum - availableSeat;
	}

	
	private int allocate (List<CourseParticipant> list, int startNum) {
		
		if (startNum == 0) {
			return 0;
		}
		
		int availableSeat = startNum;
		
		for (CourseParticipant participant : list) {
			participant.setStatus(ParticipantStatus.SUCCESSFUL);
			participant.setUpdatedBy("BPM");
			dao.updateCourseParticipant(participant, INTRANET);
			availableSeat--;
			if (availableSeat == 0) {
				break;
			}
		}
		
		return startNum - availableSeat;
	}


	private int allocateNotAttendedBeforeNotBlacklisted (Course course, Slot slot, int startNum, List<String> blacklistNrics, List<String> similarCourseId) {
		
		int availableSeat = startNum;
		
		IWelfareCourseConfig config = ServiceConfig.getInstance().getWelfareCourseConfig();
		
		// Start with Uniformed and Civilian Officers first
		
		List<CourseParticipant> uniformedParticipants = dao.getRegisteredCourseParticipants(course.getId(), slot.getId(), false, similarCourseId,
				config.uniformedOfficerServiceTypeCodes(), blacklistNrics);
		
		List<CourseParticipant> civilianParticipants = dao.getRegisteredCourseParticipants(course.getId(), slot.getId(), false, similarCourseId,
				config.civilianOfficerServiceTypeCodes(), blacklistNrics);
		
		if (uniformedParticipants.isEmpty()) {
			availableSeat = availableSeat - allocate(civilianParticipants, availableSeat);
		}
		else if (civilianParticipants.isEmpty()) {
			availableSeat = availableSeat - allocate(uniformedParticipants, availableSeat);
		}
		else {
			availableSeat = availableSeat - allocate(uniformedParticipants, civilianParticipants, availableSeat);
		}
		
		// Still have available seat, give to PNSF
		if (availableSeat > 0) {
			List<CourseParticipant> pnsfParticipants = dao.getRegisteredCourseParticipants(course.getId(), slot.getId(), false, similarCourseId, 
					config.pnsfOfficerServiceTypeCode(), blacklistNrics);
			availableSeat = availableSeat - allocate(pnsfParticipants, availableSeat);
		}
		
		return startNum - availableSeat;
	}
	
	
	private int allocateAttendedBeforeNotBlacklisted (Course course, Slot slot, int startNum, List<String> blacklistNrics, List<String> similarCourseId) {
		
		int availableSeat = startNum;
		
		List<CourseParticipant> participants = dao.getRegisteredCourseParticipants(course.getId(), slot.getId(), similarCourseId, blacklistNrics);
		
		return allocate(participants, availableSeat);
	}
	
	private int allocateBlacklisted (Course course, Slot slot, int startNum) {
		
		int availableSeat = startNum;
		
		List<CourseParticipant> participants = dao.getBlacklistedRegisteredCourseParticipants(course.getId(), slot.getId());
		
		return allocate(participants, availableSeat);
	}
	
	
	public void allocateForWithdrawal (CourseParticipant participant) throws CourseServiceException {
		
		try {
			SessionFactoryUtil.beginTransaction();
			
			Course course = dao.getCourse (participant.getCourseId());
			
			// Only need to reallocate if within cooling period
			if (course.getStatus() == CourseStatus.ACTIVATED && CourseUtil.withinCoolingPeriod(course)) {
				for (Slot slot : course.getSlots()) {
					if (slot.getId().equals(participant.getSlotId())) {
						allocateForWithdrawal(course, slot, participant);
					}
				}
			}
			
			SessionFactoryUtil.commitTransaction();
		}
		catch (Exception e) {
			logger.log(Level.SEVERE, "Fail to retrieve courses pending reminder", e);
			SessionFactoryUtil.rollbackTransaction();
		}
	}
	
	//select participants not in blacklist or not in wait-list tasks
	public void allocateForWithdrawal (Course course, Slot slot, CourseParticipant withdrawnParticipant) {
		
		List<CourseParticipant> list = dao.getNonBlacklistedCourseParticipants(course.getId(), slot.getId(), ParticipantStatus.WAIT_LIST);
		
		if (list.isEmpty()) {
			logger.info("Empty waitlist for slot:" + Util.replaceNewLine( slot.getId() ));
			
			Date withdrawalDate = new Date();
			emailSmsHelper.informNoReplacement(course, withdrawalDate);
			return;
		}
		
		List <WaitListTask> taskList = dao.getWaitListTaskList(course.getId(), slot.getId(), false);

		CourseParticipant participant = new CourseParticipant();
		
		logger.log(Level.INFO, String.format("no. of waitlist tasks=%s, no. of waitlisted participants=%s", taskList.size(), list.size()));

        for (int i = 0; i < list.size(); i++) {
			participant = list.get(i);
			String nric = participant.getNric();

			if (taskList.isEmpty()) {
				break; // No tasks, break out of the loop
			}

			// Check if participant is already selected
			boolean foundSelected = false;
			for (WaitListTask task : taskList) {
				if (nric.equals(task.getSelectedNric())) {
					if ( logger.isLoggable( Level.INFO ) ) {
						logger.log(Level.INFO, String.format("participant=%s is already selected!", nric));
					}
					foundSelected = true;
					break;
				}
			}

			if (foundSelected) {
				if (i == list.size() - 1) {
					// No valid participants remaining, take first from list
					logger.log(Level.INFO, String.format("no participant! Taking from list=%s", list.get(0).getNric()));
					participant = list.get(0);
					break;
				}
				continue; // Move to the next participant
			}

			break; // Participant is not already selected, break out of the loop
		}


		logger.log(Level.INFO, String.format("allocated for waitlist participant=%s", participant.getNric()));
		
		//inform course administrator
		Date withdrawalDate = new Date();
		
		Calendar c = Calendar.getInstance();
		c.setTime(withdrawalDate); 
		c.add(Calendar.DATE, 2);
		Date cutoffDate = c.getTime(); 
		
		emailSmsHelper.informWithdrawalTask(course, cutoffDate, withdrawalDate);
		
		WaitListTask waitListTask = new WaitListTask(null, course.getId(), slot.getId(), withdrawnParticipant.getNric(), participant.getNric(), withdrawnParticipant.getName(), participant.getName(), withdrawnParticipant.getDepartment(), participant.getDepartment(), new Date(), false, new Date(), "BPM");
		dao.saveWaitListTask(waitListTask);
	}
	
	
	public void processBroadcastOutcomeTask () {
		
		// Check if working day... 
		// If not working day, don't need to continue.
		if (!isWorkingDay (new Date ())) {
			logger.info("Non working day, don't need to process allocation outcome broadcast task");
			return;
		}

		logger.log(Level.INFO, "processBroadcastOutcomeTask() started");
		List<Course> courses = null;
		
		try {
			SessionFactoryUtil.beginTransaction();

			courses = dao.getCoursePendingOutcomeBroadcast();
			
			SessionFactoryUtil.commitTransaction();
		}
		catch (Exception e) {
			logger.log(Level.SEVERE, "Fail to retrieve courses pending allocation outcome broadcast", e);
			SessionFactoryUtil.rollbackTransaction();
		}
		
		for (Course course : courses) {
			//Handle cases that course administrator trigger to send outcome
			//before system take over
			if (course.getRegistrationConfig().isOutcomeBroadcasted()) {
				logger.info(String.format("id=%s has been triggered by admin.", course.getId()));
				broadcastAllocationOutcome (course);
				continue;
			}
			//Handle course that are after the system take over date 
			Date takeOverCutoffDate = computeQueryDate(course.getTakeoverDays());
			logger.info(String.format("id=%s, closeDate=%s, takeoverDays=%s, takeOverCutoffDate=%s", course.getId(), course.getRegistrationConfig().getCloseDate().toString(), course.getTakeoverDays(), takeOverCutoffDate.toString()));
			if (DateUtils.isBeforeDay(course.getRegistrationConfig().getCloseDate(), takeOverCutoffDate)) {
				broadcastAllocationOutcome (course);
			}
			
		}
		logger.log(Level.INFO, "processBroadcastOutcomeTask() ended");
	}
	
	private boolean isWorkingDay (Date date) {
		GregorianCalendar cal = new GregorianCalendar();
		cal.setTime(date);
		
		return isWorkingDay(cal);
	}
	
	private boolean isWorkingDay (Calendar cal) {
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK);
		
		if (dayOfWeek == Calendar.SATURDAY || dayOfWeek == Calendar.SUNDAY) {
			return false;
		}
		
		boolean isWorkingDay = true;
		boolean isNestedTx = SessionFactoryUtil.isTransactionActive();
		
		try {
			if (!isNestedTx) {
				SessionFactoryUtil.beginTransaction();
			}
			
			// If not public holiday, then is working day.
			isWorkingDay = !calendarDAO.isPublicHoliday (cal.getTime());
			
			if (!isNestedTx) {
				SessionFactoryUtil.commitTransaction();
			}
		}
		catch (Exception e) {
			logger.log(Level.WARNING, "Fail to check if public holiday", e);
			if (!isNestedTx) {
				SessionFactoryUtil.rollbackTransaction();
			}
		}
		
		return isWorkingDay;
	}
	
	
	private Date computeQueryDate (int days) {
		
		GregorianCalendar cal = new GregorianCalendar();
		
		int businessDay = 0;
		
		while (businessDay < days) {
			cal.add(Calendar.DATE, -1);
			if (isWorkingDay (cal)) {
				businessDay = businessDay + 1;
			}
		}
		  
		return cal.getTime();
	}
	
	private Date computeCutoffDate (Date fromDate, int days) {
		
		GregorianCalendar cal = new GregorianCalendar();
		cal.setTime(fromDate);
		
		int businessDay = 0;
		
		while (businessDay < days) {
			cal.add(Calendar.DATE, 1);
			if (isWorkingDay (cal)) {
				businessDay = businessDay + 1;
			}
		}
		
		return cal.getTime();
	}
	
	private void broadcastAllocationOutcome (Course course) {
		
		try {
			SessionFactoryUtil.beginTransaction();
			
			emailSmsHelper.informAllocationStatus (course);		
			
			OutcomeBroadcastTaskStatus status = new OutcomeBroadcastTaskStatus(course.getId(), new Date ());
			dao.saveOutcomeBroadcastTaskStatus(status);
			
			course.getRegistrationConfig().setOutcomeBroadcasted(true);
			dao.updateCourse(course, INTRANET);
			
			SessionFactoryUtil.commitTransaction();
		}
		catch (Exception e) {
			logger.log(Level.SEVERE, "Fail to broadcast courses allocation outcome", e);
			SessionFactoryUtil.rollbackTransaction();
		}
	}
	
	
	public void processBroadcastOutcomeReminder () {
		
		// Check if working day... 
		// If not working day, don't need to continue.
		if (!isWorkingDay (new Date ())) {
			logger.info("Non working day, don't need to process allocation outcome broadcast reminder task");
			return;
		}

		logger.log(Level.INFO, "processBroadcastOutcomeReminder() started");
		List<Course> courses = null;
			
		try {
			SessionFactoryUtil.beginTransaction();

			courses = dao.getCoursePendingOutcomeConfirmation();	
			
			SessionFactoryUtil.commitTransaction();
		}
		catch (Exception e) {
			logger.log(Level.SEVERE, "Fail to retrieve courses pending allocation outcome confirmation", e);
			SessionFactoryUtil.rollbackTransaction();
		}
			
		for (Course course : courses) {
			try {
				SessionFactoryUtil.beginTransaction();
				Date queryDate = computeQueryDate(course.getReminderDays());
				logger.info(String.format("id=%s, closeDate=%s, ,reminderDays=%s, queryDate=%s", course.getId(), course.getRegistrationConfig().getCloseDate().toString(), course.getReminderDays(), queryDate.toString()));
				if (DateUtils.isBeforeDay(course.getRegistrationConfig().getCloseDate(), queryDate)) {
				
					Date cutoffDate = computeCutoffDate(course.getRegistrationConfig().getCloseDate(), course.getTakeoverDays());
				
					emailSmsHelper.remindConfirmRegistrationOutcome (course, cutoffDate);
				
				}
				
				SessionFactoryUtil.commitTransaction();
			}
			catch (Exception e) {
				logger.log(Level.SEVERE, "Fail to send reminder for allocation outcome confirmation for course:" + course.getId(), e);
				SessionFactoryUtil.rollbackTransaction();
			}
		}
		logger.log(Level.INFO, "processBroadcastOutcomeTask() ended");
	}
	
}
